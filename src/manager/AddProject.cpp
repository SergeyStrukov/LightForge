/* AddProject.cpp */
//----------------------------------------------------------------------------------------
//
//  Project: LightForge 1.00
//
//  License: Boost Software License - Version 1.0 - August 17th, 2003
//
//            see http://www.boost.org/LICENSE_1_0.txt or the local copy
//
//  Copyright (c) 2023 Sergey Strukov. All rights reserved.
//
//----------------------------------------------------------------------------------------

#include "Command.h"
#include "ProjectReader.h"
#include "TargetReader.h"

namespace App {

namespace {

class PrintList
 {
    const std::vector<String> &list;

  public:

   explicit PrintList(const std::vector<String> &list_) : list(list_) {}

   void print(std::ostream &out) const
    {
     for(const String &str : list ) out << " " << str ;
    }
 };

} // local namespace

static void CreateFolder(const Path &folder)
 {
  if( !std::filesystem::create_directory(folder) )
    {
     std::cout << "Cannot create folder " << folder << std::endl ;

     throw std::runtime_error("create folder error");
    }
 }

static void CreateProjectMakefile(const Path &folder,const Path &projPath)
 {
  std::ofstream out(folder/"Makefile-project");

  out << "# Makefile-project AUTOGENERATED, DON'T EDIT\n\n" ;

  out << "PROJECT_PATH = " << projPath.native() << "\n\n" ;

  out.close();

  if( !out )
    {
     throw std::runtime_error("'Makefile-project' creation error");
    }
 }

static void CreateTargetMakefile(const Path &dir,const TargetInfo &target)
 {
  std::ofstream out(dir/"Makefile");

  out << "# Makefile AUTOGENERATED, DON'T EDIT\n\n" ;

  out << "include ../Makefile-project\n\n" ;

  out << "TARGET_PATH = " << target.path.native() << "\n\n" ;

  out << "TARGET = " << target.outName << "\n\n" ;

  switch( target.kind )
    {
     case TargetLib :
      {
       out << "TARGET_BUILD = Makefile-ar\n\n" ;
      }
     break;

     case TargetExe :
      {
       out << "TARGET_BUILD = Makefile-exe\n\n" ;
      }
     break;
    }

  out << "SRCDIR_LIST =" << PrintList(target.src) << "\n\n" ;

  out << "include ../../Makefile-tools\n\n" ;

  out << "include ../../../Makefile-rules\n\n" ;

  out.close();

  if( !out )
    {
     throw std::runtime_error("'Makefile-project' creation error");
    }
 }

static void CreateTargetBaselist(const Path &dir,const TargetInfo &target)
 {
  std::ofstream out(dir/"BaseList.txt");

  for(const BaseSpec &base : target.base )
    {
     out << base.proj << "." << base.target << "\n" ;
    }

  out.close();

  if( !out )
    {
     throw std::runtime_error("'BaseList.txt' creation error");
    }
 }

static void CreateTargetCCpublicOpt(const Path &dir,const String &projPath,const TargetInfo &target)
 {
  std::ofstream out(dir/"CCpublic-opt.txt");

  for(const String &str : target.inc )
    {
     out << "-I../" << projPath << "/" << target.path.native() << "/" << str << "\n" ;
    }

  out.close();

  if( !out )
    {
     throw std::runtime_error("'CCpublic-opt.txt' creation error");
    }
 }

static void CreateTargetCCprivateOpt(const Path &dir,const String &projPath,const TargetInfo &target)
 {
  std::ofstream out(dir/"CCprivate-opt.txt");

  for(const String &str : target.incPrivate )
    {
     out << "-I../" << projPath << "/" << target.path.native() << "/" << str << "\n" ;
    }

  out.close();

  if( !out )
    {
     throw std::runtime_error("'CCprivate-opt.txt' creation error");
    }
 }

static void CreateTargetLDpublicOpt(const Path &dir,const String &projName,const TargetInfo &target)
 {
  std::ofstream out(dir/"LDpublic-opt.txt");

  if( target.kind==TargetLib )
    {
     out << "../../" << projName << "/" << target.name << "/" << target.outName << "\n" ;
    }

  out.close();

  if( !out )
    {
     throw std::runtime_error("'LDpublic-opt.txt' creation error");
    }
 }

static void AddTarget(const Path &folder,const String &projName,const String &projPath,const TargetInfo &target)
 {
  Path dir=folder/target.name;

  CreateFolder(dir);
  CreateFolder(dir/"asm");
  CreateFolder(dir/"dep");
  CreateFolder(dir/"obj");

  CreateTargetMakefile(dir,target);
  CreateTargetBaselist(dir,target);
  CreateTargetCCpublicOpt(dir,projPath,target);
  CreateTargetCCprivateOpt(dir,projPath,target);
  CreateTargetLDpublicOpt(dir,projName,target);
 }

static void AddProject(const Path &forge,const char *build,const String &projName,Path projRoot,const std::vector<TargetReader> &targets)
 {
  Path folder=forge/"build"/build/projName;

  CreateFolder(folder);

  Path projPath=Relative(projRoot,std::filesystem::canonical(folder));

  CreateProjectMakefile(folder,projPath);

  for(const TargetReader &target : targets )
    {
     AddTarget(folder,projName,projPath,target.getInfo());
    }
 }

void AddProject(Path curpath,Path forge,Path proj,const char *const*build,int buildCount)
 {
  if( !buildCount )
    {
     static const char *const buildStd[1]={"std"};

     build=buildStd;
     buildCount=1;
    }

  String infoFile=forge/"projects";

  ProjectListReader info(infoFile);

  Path projRoot=std::filesystem::canonical(curpath/proj);

  ProjectReader inp(projRoot/"PROJECT");

  const String &projName=inp.getName();
  const std::vector<String> &baseList=inp.getBaseList();

  TargetListReader targets(projRoot);

  // TODO check bases

  info.addProject(projName,baseList);

  for(int ind=0; ind<buildCount ;ind++)
    {
     AddProject(forge,build[ind],projName,projRoot,targets.getList());
    }

  info.save(infoFile);
 }

} // namespace App
