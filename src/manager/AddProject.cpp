/* AddProject.cpp */
//----------------------------------------------------------------------------------------
//
//  Project: LightForge 1.00
//
//  License: Boost Software License - Version 1.0 - August 17th, 2003
//
//            see http://www.boost.org/LICENSE_1_0.txt or the local copy
//
//  Copyright (c) 2023 Sergey Strukov. All rights reserved.
//
//----------------------------------------------------------------------------------------

#include "Command.h"
#include "ProjectReader.h"
#include "TargetReader.h"

namespace App {

namespace {

class PrintList
 {
    const std::vector<String> &list;

  public:

   explicit PrintList(const std::vector<String> &list_) : list(list_) {}

   void print(std::ostream &out) const
    {
     for(const String &str : list ) out << " " << str ;
    }
 };

} // local namespace

static void CreateFolder(const Path &folder)
 {
  if( !CreateDir(folder) )
    {
     std::cout << "Cannot create folder " << folder << std::endl ;

     throw std::runtime_error("create folder error");
    }
 }

static void CreateProjectMakefile(const Path &folder,const Path &projPath)
 {
  std::ofstream out(folder/"Makefile-project");

  out << "# Makefile-project AUTOGENERATED, DON'T EDIT\n\n" ;

  out << "PROJECT_PATH = " << projPath.native() << "\n\n" ;

  out.close();

  if( !out )
    {
     throw std::runtime_error("'Makefile-project' creation error");
    }
 }

static void CreateMakefile(const Path &folder,const std::vector<TargetReader> &targets)
 {
  std::ofstream out(folder/"Makefile");

  out << "# Makefile AUTOGENERATED, DON'T EDIT\n\n" ;

  for(const TargetReader &obj : targets )
    {
     const String &name=obj.getInfo().name;

     out << ".PHONY: " << name << "\n\n" ;
     out << name << ":\n" ;
     out << "\t$(MAKE) -C " << name << " deep\n\n" ;
    }

  out << ".PHONY: cleanproj\n\n" ;
  out << "cleanproj:\n" ;

  for(const TargetReader &obj : targets )
    {
     const String &name=obj.getInfo().name;

     out << "\t$(MAKE) -C " << name << " clean\n" ;
    }

  out << "\n" ;

  out.close();

  if( !out )
    {
     throw std::runtime_error("'Makefile-project' creation error");
    }
 }

static void CreateTargetMakefile(const Path &dir,const TargetInfo &target)
 {
  std::ofstream out(dir/"Makefile");

  out << "# Makefile AUTOGENERATED, DON'T EDIT\n\n" ;

  out << "include ../Makefile-project\n\n" ;

  out << "TARGET_PATH = " << target.path.native() << "\n\n" ;

  out << "TARGET_ROOT = ../$(PROJECT_PATH)/$(TARGET_PATH)\n\n" ;

  switch( target.kind )
    {
     case TargetLib :
      {
       out << "TARGET = " << target.outName << "\n\n" ;

       out << "TARGET_BUILD = Makefile-ar\n\n" ;

       out << "-include $(TARGET_ROOT)/Makefile-opt\n\n" ;
      }
     break;

     case TargetExe :
      {
       out << "TARGET = " << target.outName << "\n\n" ;

       out << "TARGET_BUILD = Makefile-exe\n\n" ;

       out << "-include $(TARGET_ROOT)/Makefile-opt\n\n" ;

       out << "-include $(TARGET_ROOT)/Makefile-runopt\n\n" ;
      }
     break;

     case TargetPregen :
      {
       out << "TARGET = pregen-time.txt\n\n" ;

       out << "RUN_SRC = " ;

       for(const String &arg : target.pregenInp )
         out << "$(TARGET_ROOT)/" << arg << " \\\n" ;

       out << "\n\n" ;

       out << "RUN_OPT = $(TARGET_ROOT)/" << target.outName << "\n\n" ;

       out << "TARGET_BUILD = Makefile-pregen\n\n" ;

       out << "-include $(TARGET_ROOT)/Makefile-opt\n\n" ;
      }
     break;

     case TargetMake :
      {
       out << ".PHONY: all clean\n\n" ;

       out << "all:\n" ;
       out << "\texport LIGHT_FORGE_BUILD=" << "$(abspath ../..)" << " ; $(MAKE) -C $(TARGET_ROOT)\n\n" ;

       out << "clean:\n\n" ;
      }
     break;

     case TargetGroup :
      {
       out << ".PHONY: all clean\n\n" ;

       out << "all:\n\n" ;

       out << "clean:\n\n" ;
      }
     break;
    }

  if( target.kind!=TargetMake && target.kind!=TargetGroup )
    {
     out << "SRCDIR_LIST =" << PrintList(target.src) << "\n\n" ;

     out << "include ../../Makefile-tools\n\n" ;

     out << "include ../../../Makefile-rules\n\n" ;
    }
  else
    {
     out << "include ../../Makefile-tools\n\n" ;

     out << "include ../../../Makefile-deeprules\n\n" ;
    }

  out.close();

  if( !out )
    {
     throw std::runtime_error("'Makefile-project' creation error");
    }
 }

static void CheckBase(const Path &buildDir,const String &proj,const String &target)
 {
  Path path=buildDir/proj/target;

  if( !PathExists(path) )
    {
     std::cout << "Base target " << proj << "." << target << " does not exist" << std::endl ;

     throw std::runtime_error("Bad base target");
    }
 }

static void CheckBase(const String &target,const std::set<String> &nameSet)
 {
  if( nameSet.find(target)==nameSet.end() )
    {
     std::cout << "Base target " << target << " does not exist" << std::endl ;

     throw std::runtime_error("Bad base target");
    }
 }

static void CreateTargetBaselist(const Path &buildDir,const Path &dir,const String &projName,const TargetInfo &target,const std::set<String> &nameSet)
 {
  std::ofstream out(dir/"BaseList.txt");

  for(const BaseSpec &base : target.base )
    {
     if( base.proj.empty() )
       {
        CheckBase(base.target,nameSet);

        out << "../../" << projName << "/" << base.target << "\n" ;
       }
     else
       {
        CheckBase(buildDir,base.proj,base.target);

        out << "../../" << base.proj << "/" << base.target << "\n" ;
       }
    }

  out.close();

  if( !out )
    {
     throw std::runtime_error("'BaseList.txt' creation error");
    }
 }

static void CreateTargetKind(const Path &dir,TargetKind kind)
 {
  std::ofstream out(dir/"TargetKind.txt");

  out << GetTag(kind) ;

  out.close();

  if( !out )
    {
     throw std::runtime_error("'TargetKind.txt' creation error");
    }
 }

static void CreateTargetCCpublicOpt(const Path &dir,const String &projPath,const TargetInfo &target)
 {
  std::ofstream out(dir/"CCpublic-opt.txt");

  for(const String &str : target.inc )
    {
     out << "-I../" << projPath << "/" << target.path.native() << "/" << str << "\n" ;
    }

  out.close();

  if( !out )
    {
     throw std::runtime_error("'CCpublic-opt.txt' creation error");
    }
 }

static void CreateTargetCCprivateOpt(const Path &dir,const String &projPath,const TargetInfo &target)
 {
  std::ofstream out(dir/"CCprivate-opt.txt");

  for(const String &str : target.incPrivate )
    {
     out << "-I../" << projPath << "/" << target.path.native() << "/" << str << "\n" ;
    }

  out.close();

  if( !out )
    {
     throw std::runtime_error("'CCprivate-opt.txt' creation error");
    }
 }

static void CreateTargetLDpublicOpt(const Path &dir,const String &projName,const TargetInfo &target)
 {
  std::ofstream out(dir/"LDpublic-opt.txt");

  if( target.kind==TargetLib )
    {
     out << "../../" << projName << "/" << target.name << "/" << target.outName << "\n" ;
    }

  out.close();

  if( !out )
    {
     throw std::runtime_error("'LDpublic-opt.txt' creation error");
    }
 }

static void AddTarget(const Path &buildDir,const Path &folder,const String &projName,const String &projPath,const TargetInfo &target,const std::set<String> &nameSet)
 {
  Path dir=folder/target.name;

  CreateFolder(dir);

  if( target.kind!=TargetMake && target.kind!=TargetGroup )
    {
     CreateFolder(dir/"asm");
     CreateFolder(dir/"dep");
     CreateFolder(dir/"obj");

     if( target.kind==TargetExe )
       {
        CreateFolder(dir/"out");
       }
    }

  CreateTargetMakefile(dir,target);
  CreateTargetBaselist(buildDir,dir,projName,target,nameSet);
  CreateTargetKind(dir,target.kind);
  CreateTargetCCpublicOpt(dir,projPath,target);
  CreateTargetCCprivateOpt(dir,projPath,target);
  CreateTargetLDpublicOpt(dir,projName,target);
 }

static void AddProject(const Path &forge,const char *build,const String &projName,Path projRoot,const std::vector<String> &baseList,const std::vector<TargetReader> &targets,const std::set<String> &nameSet)
 {
  Path buildDir=forge/"build"/build;
  String infoFile=buildDir/"PROJECTS";

  ProjectListReader info(infoFile);

  info.addProject(projName,baseList);

  Path folder=buildDir/projName;

  CreateFolder(folder);

  Path projPath=Relative(projRoot,toCanonical(folder));

  CreateProjectMakefile(folder,projPath);

  CreateMakefile(folder,targets);

  for(const TargetReader &target : targets )
    {
     AddTarget(buildDir,folder,projName,projPath,target.getInfo(),nameSet);
    }

  info.save(infoFile);
 }

void AddProject(Path curpath,Path forge,Path proj,const char *const*build,int buildCount)
 {
  if( !buildCount )
    {
     static const char *const buildStd[1]={"std"};

     build=buildStd;
     buildCount=1;
    }

  Path projRoot=toCanonical(curpath/proj);

  ProjectReader inp(projRoot/"PROJECT");

  const String &projName=inp.getName();
  const std::vector<String> &baseList=inp.getBaseList();

  TargetListReader targets(projRoot);

  targets.checkBases(baseList);

  for(int ind=0; ind<buildCount ;ind++)
    {
     AddProject(forge,build[ind],projName,projRoot,baseList,targets.getList(),targets.getNameSet());
    }
 }

} // namespace App
